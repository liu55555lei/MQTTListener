# MQTT消息存储优化方案

## 优化背景

原有的MQTT消息存储方案将所有消息信息（包括JSON内容）都存储在单一的`mqtt_message`表中，这导致了以下问题：

1. **查询效率低下**：由于JSON内容通常较大，频繁查询会影响性能
2. **表结构臃肿**：主表包含了不常用的JSON数据，增加了表的体积
3. **索引效率低**：大字段影响索引的创建和使用效率

## 优化方案

### 1. 表结构分离

将原来的单一表拆分为两个表：

#### mqtt_message（主表）
- 存储消息的基本信息
- 不包含JSON内容
- 使用雪花算法生成ID（替代自增ID）
- 字段：id, channel_name, identifier_value, receive_time, status

#### mqtt_message_detail（明细表）
- 存储消息的JSON内容
- 与主表通过相同的ID关联
- 字段：id, json_content

### 2. ID生成策略

- 使用雪花算法（Snowflake）生成分布式唯一ID
- 替代原有的自增ID，提高分布式环境下的性能
- 主表和明细表使用相同的ID，确保数据一致性

### 3. 存储流程

1. 系统收到MQTT消息
2. 使用雪花算法生成唯一ID
3. 将基本信息存储到`mqtt_message`表
4. 将JSON内容存储到`mqtt_message_detail`表
5. 两个操作在同一事务中完成，确保数据一致性

## 性能优势

1. **查询效率提升**：主表不包含大字段，查询速度显著提升
2. **索引优化**：主表字段较少，索引创建和使用更高效
3. **存储优化**：按需加载JSON内容，减少内存占用
4. **分布式友好**：雪花算法ID支持分布式环境

## 数据迁移

提供了完整的数据库迁移脚本（`migration.sql`），包括：

1. 创建新的明细表
2. 数据迁移（将原有JSON数据迁移到明细表）
3. 主表结构优化（移除JSON字段）
4. 索引重建

## API兼容性

- 查询接口保持不变，内部自动关联两个表
- 详情接口返回完整信息（包括JSON内容）
- 导出功能已更新，支持新的表结构

## 使用说明

### 部署步骤

1. 备份现有数据库
2. 执行`migration.sql`迁移脚本
3. 部署新版本代码
4. 验证数据完整性

### 注意事项

- 迁移前请务必备份数据库
- 迁移过程中服务会短暂不可用
- 建议在业务低峰期执行迁移

## 监控建议

1. 监控主表查询性能
2. 监控明细表存储空间使用情况
3. 监控雪花算法ID生成性能
4. 定期检查数据一致性
